#!/usr/bin/env python3
"""
VALIDADOR DE OPTIMIZACIONES - SISTEMA SCJN
Verifica que las optimizaciones est√©n correctamente implementadas
Sin dependencias externas, solo Python est√°ndar
"""

import os
import sys
import json
import sqlite3
from datetime import datetime
from pathlib import Path

def print_header(title):
    """Imprimir encabezado con formato"""
    print(f"\nüîç {title}")
    print("-" * 50)

def check_file_exists(file_path, description):
    """Verificar que un archivo existe"""
    if Path(file_path).exists():
        print(f"‚úÖ {description}: {file_path}")
        return True
    else:
        print(f"‚ùå {description} FALTANTE: {file_path}")
        return False

def check_directory_structure():
    """Verificar estructura de directorios optimizada"""
    print_header("ESTRUCTURA DE DIRECTORIOS")
    
    directories = [
        ("src/", "Directorio fuente"),
        ("src/scraper/", "M√≥dulos de scraping"),
        ("src/storage/", "M√≥dulos de almacenamiento"),
        ("src/database/", "M√≥dulos de base de datos"),
        ("src/utils/", "Utilidades"),
        ("logs/", "Directorio de logs"),
        ("data/", "Directorio de datos"),
        ("data/pdfs/", "Directorio de PDFs"),
    ]
    
    created_dirs = []
    for dir_path, description in directories:
        if Path(dir_path).exists():
            print(f"‚úÖ {description}: {dir_path}")
        else:
            print(f"‚ö†Ô∏è Creando {description}: {dir_path}")
            Path(dir_path).mkdir(parents=True, exist_ok=True)
            created_dirs.append(dir_path)
    
    if created_dirs:
        print(f"üìÅ Directorios creados: {len(created_dirs)}")
    
    return True

def check_optimized_files():
    """Verificar archivos optimizados"""
    print_header("ARCHIVOS OPTIMIZADOS")
    
    files = [
        ("src/config.py", "Configuraci√≥n optimizada"),
        ("src/utils/logger.py", "Sistema de logging avanzado"),
        ("src/scraper/optimized_scraper.py", "Scraper optimizado"),
        ("optimized_production_scraper.py", "Script de producci√≥n optimizado"),
        ("test_end_to_end_optimized.py", "Pruebas end-to-end"),
        ("requirements.txt", "Dependencias actualizadas"),
        ("env.example", "Configuraci√≥n de entorno"),
        ("OPTIMIZACION_COMPLETA.md", "Documentaci√≥n de optimizaciones")
    ]
    
    existing_files = 0
    for file_path, description in files:
        if check_file_exists(file_path, description):
            existing_files += 1
    
    print(f"\nüìä Archivos optimizados: {existing_files}/{len(files)}")
    return existing_files / len(files) > 0.8  # 80% de archivos deben existir

def check_configuration_structure():
    """Verificar estructura de configuraci√≥n"""
    print_header("CONFIGURACI√ìN")
    
    config_file = "src/config.py"
    if not Path(config_file).exists():
        print(f"‚ùå Archivo de configuraci√≥n no encontrado: {config_file}")
        return False
    
    try:
        with open(config_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Verificar elementos clave de la configuraci√≥n optimizada
        checks = [
            ("ConfigurationError", "Manejo de errores de configuraci√≥n"),
            ("get_config", "Funci√≥n de configuraci√≥n por entorno"),
            ("validate_config", "Validaci√≥n de configuraci√≥n"),
            ("PARALLEL_DOWNLOADS", "Configuraci√≥n de paralelizaci√≥n"),
            ("LOG_LEVEL", "Configuraci√≥n de logging"),
            ("BATCH_SIZE", "Configuraci√≥n de lotes"),
        ]
        
        found_elements = 0
        for element, description in checks:
            if element in content:
                print(f"‚úÖ {description}")
                found_elements += 1
            else:
                print(f"‚ùå {description} no encontrado")
        
        print(f"\nüìä Elementos de configuraci√≥n: {found_elements}/{len(checks)}")
        return found_elements / len(checks) > 0.7
        
    except Exception as e:
        print(f"‚ùå Error leyendo configuraci√≥n: {e}")
        return False

def check_logging_system():
    """Verificar sistema de logging"""
    print_header("SISTEMA DE LOGGING")
    
    logger_file = "src/utils/logger.py"
    if not Path(logger_file).exists():
        print(f"‚ùå Sistema de logging no encontrado: {logger_file}")
        return False
    
    try:
        with open(logger_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Verificar elementos del sistema de logging
        checks = [
            ("ScraperFormatter", "Formateador personalizado"),
            ("PerformanceLogger", "Logger de performance"),
            ("performance_monitor", "Decorador de monitoreo"),
            ("RotatingFileHandler", "Rotaci√≥n de archivos"),
            ("setup_logging", "Configuraci√≥n de logging"),
        ]
        
        found_elements = 0
        for element, description in checks:
            if element in content:
                print(f"‚úÖ {description}")
                found_elements += 1
            else:
                print(f"‚ùå {description} no encontrado")
        
        print(f"\nüìä Elementos de logging: {found_elements}/{len(checks)}")
        return found_elements / len(checks) > 0.7
        
    except Exception as e:
        print(f"‚ùå Error leyendo sistema de logging: {e}")
        return False

def check_optimized_scraper():
    """Verificar scraper optimizado"""
    print_header("SCRAPER OPTIMIZADO")
    
    scraper_file = "src/scraper/optimized_scraper.py"
    if not Path(scraper_file).exists():
        print(f"‚ùå Scraper optimizado no encontrado: {scraper_file}")
        return False
    
    try:
        with open(scraper_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Verificar elementos del scraper optimizado
        checks = [
            ("OptimizedSCJNScraper", "Clase principal optimizada"),
            ("ThreadPoolExecutor", "Paralelizaci√≥n"),
            ("cache", "Sistema de cache"),
            ("performance_monitor", "Monitoreo de performance"),
            ("ScrapingResult", "Resultado estructurado"),
            ("SessionStats", "Estad√≠sticas de sesi√≥n"),
            ("aiohttp", "Descarga as√≠ncrona"),
        ]
        
        found_elements = 0
        for element, description in checks:
            if element in content:
                print(f"‚úÖ {description}")
                found_elements += 1
            else:
                print(f"‚ö†Ô∏è {description} no encontrado")
        
        print(f"\nüìä Elementos del scraper: {found_elements}/{len(checks)}")
        return found_elements / len(checks) > 0.6
        
    except Exception as e:
        print(f"‚ùå Error leyendo scraper optimizado: {e}")
        return False

def check_database_setup():
    """Verificar configuraci√≥n de base de datos"""
    print_header("BASE DE DATOS")
    
    # Crear directorio de datos si no existe
    Path("data").mkdir(exist_ok=True)
    
    # Probar creaci√≥n de base de datos SQLite
    db_path = "data/test_validation.db"
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # Crear tabla de prueba
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS test_table (
                id INTEGER PRIMARY KEY,
                name TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Insertar datos de prueba
        cursor.execute("INSERT INTO test_table (name) VALUES (?)", ("test_optimization",))
        conn.commit()
        
        # Verificar datos
        cursor.execute("SELECT COUNT(*) FROM test_table")
        count = cursor.fetchone()[0]
        
        conn.close()
        
        print(f"‚úÖ Base de datos SQLite funcionando")
        print(f"‚úÖ Registros de prueba: {count}")
        
        # Limpiar archivo de prueba
        Path(db_path).unlink(missing_ok=True)
        
        return True
        
    except Exception as e:
        print(f"‚ùå Error en base de datos: {e}")
        return False

def check_environment_config():
    """Verificar configuraci√≥n de entorno"""
    print_header("CONFIGURACI√ìN DE ENTORNO")
    
    env_file = "env.example"
    if not Path(env_file).exists():
        print(f"‚ùå Archivo de entorno no encontrado: {env_file}")
        return False
    
    try:
        with open(env_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Verificar variables importantes
        checks = [
            ("ENVIRONMENT=", "Variable de entorno"),
            ("PARALLEL_DOWNLOADS=", "Configuraci√≥n de paralelizaci√≥n"),
            ("LOG_LEVEL=", "Nivel de logging"),
            ("MAX_RETRIES=", "Reintentos m√°ximos"),
            ("BATCH_SIZE=", "Tama√±o de lote"),
            ("SELENIUM_HEADLESS=", "Configuraci√≥n de Selenium"),
        ]
        
        found_vars = 0
        for var, description in checks:
            if var in content:
                print(f"‚úÖ {description}")
                found_vars += 1
            else:
                print(f"‚ùå {description} no encontrada")
        
        print(f"\nüìä Variables de entorno: {found_vars}/{len(checks)}")
        return found_vars / len(checks) > 0.8
        
    except Exception as e:
        print(f"‚ùå Error leyendo configuraci√≥n de entorno: {e}")
        return False

def generate_validation_report():
    """Generar reporte de validaci√≥n"""
    print_header("GENERANDO REPORTE")
    
    report = {
        "validation_date": datetime.now().isoformat(),
        "python_version": sys.version,
        "platform": sys.platform,
        "working_directory": os.getcwd(),
        "tests_run": True,
        "summary": "Validaci√≥n b√°sica de optimizaciones completada"
    }
    
    report_file = "data/validation_report.json"
    try:
        Path("data").mkdir(exist_ok=True)
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        print(f"‚úÖ Reporte guardado: {report_file}")
        return True
        
    except Exception as e:
        print(f"‚ùå Error guardando reporte: {e}")
        return False

def main():
    """Funci√≥n principal de validaci√≥n"""
    print("üèõÔ∏è IA-IUS-SCRAPPING: VALIDACI√ìN DE OPTIMIZACIONES")
    print("=" * 70)
    print(f"üïê Iniciado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 70)
    
    # Ejecutar todas las validaciones
    tests = [
        ("Estructura de Directorios", check_directory_structure),
        ("Archivos Optimizados", check_optimized_files),
        ("Configuraci√≥n", check_configuration_structure),
        ("Sistema de Logging", check_logging_system),
        ("Scraper Optimizado", check_optimized_scraper),
        ("Base de Datos", check_database_setup),
        ("Configuraci√≥n de Entorno", check_environment_config),
    ]
    
    passed_tests = 0
    total_tests = len(tests)
    
    for test_name, test_func in tests:
        try:
            if test_func():
                passed_tests += 1
                print(f"‚úÖ {test_name}: PAS√ì")
            else:
                print(f"‚ùå {test_name}: FALL√ì")
        except Exception as e:
            print(f"‚ùå {test_name}: ERROR - {e}")
    
    # Generar reporte
    generate_validation_report()
    
    # Resumen final
    print("\n" + "=" * 70)
    print("üìä RESUMEN DE VALIDACI√ìN")
    print("=" * 70)
    print(f"üìä Total de pruebas: {total_tests}")
    print(f"‚úÖ Pruebas exitosas: {passed_tests}")
    print(f"‚ùå Pruebas fallidas: {total_tests - passed_tests}")
    
    success_rate = (passed_tests / total_tests) * 100
    print(f"üìà Tasa de √©xito: {success_rate:.1f}%")
    
    if success_rate >= 85:
        print("üéâ ¬°OPTIMIZACIONES VALIDADAS EXITOSAMENTE!")
        print("üöÄ Sistema listo para pruebas adicionales")
        exit_code = 0
    elif success_rate >= 70:
        print("‚ö†Ô∏è Optimizaciones parcialmente validadas")
        print("üîß Revisar elementos faltantes")
        exit_code = 1
    else:
        print("‚ùå Validaci√≥n fall√≥")
        print("üõ†Ô∏è Sistema necesita revisi√≥n")
        exit_code = 2
    
    print(f"\nüïê Finalizado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 70)
    
    return exit_code

if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code)